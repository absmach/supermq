/*
 * SuperMQ Channels Service
 *
 * This is the Channels Server based on the OpenAPI 3.0 specification.  It is the HTTP API for managing platform channels. You can now help us improve the API whether it's by making changes to the definition itself or to the code. Some useful links: - [The SuperMQ repository](https://github.com/absmach/supermq) 
 *
 * The version of the OpenAPI document: 0.18.0
 * Contact: info@abstractmachines.fr
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`connect_clients_and_channels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConnectClientsAndChannelsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`connect_clients_to_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ConnectClientsToChannelError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disconnect_clients_and_channels`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisconnectClientsAndChannelsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disconnect_clients_from_channel`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisconnectClientsFromChannelError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}


/// Connect clients specified by IDs to channels specified by IDs. Channel and client are owned by user identified using the provided access token. 
pub async fn connect_clients_and_channels(configuration: &configuration::Configuration, domain_id: &str, connection_req_schema: models::ConnectionReqSchema) -> Result<(), Error<ConnectClientsAndChannelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_body_connection_req_schema = connection_req_schema;

    let uri_str = format!("{}/{domainID}/channels/connect", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_connection_req_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConnectClientsAndChannelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Connects clients to a channel that is identified by the channel ID. 
pub async fn connect_clients_to_channel(configuration: &configuration::Configuration, domain_id: &str, chan_id: &str, channel_connection_req_schema: models::ChannelConnectionReqSchema) -> Result<(), Error<ConnectClientsToChannelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_chan_id = chan_id;
    let p_body_channel_connection_req_schema = channel_connection_req_schema;

    let uri_str = format!("{}/{domainID}/channels/{chanID}/connect", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), chanID=crate::apis::urlencode(p_path_chan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_channel_connection_req_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<ConnectClientsToChannelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disconnect clients specified by IDs from channels specified by IDs. Channel and client are owned by user identified using the provided access token. 
pub async fn disconnect_clients_and_channels(configuration: &configuration::Configuration, domain_id: &str, connection_req_schema: models::ConnectionReqSchema) -> Result<(), Error<DisconnectClientsAndChannelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_body_connection_req_schema = connection_req_schema;

    let uri_str = format!("{}/{domainID}/channels/disconnect", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_connection_req_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DisconnectClientsAndChannelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disconnects clients to a channel that is identified by the channel ID. 
pub async fn disconnect_clients_from_channel(configuration: &configuration::Configuration, domain_id: &str, chan_id: &str, channel_connection_req_schema: models::ChannelConnectionReqSchema) -> Result<(), Error<DisconnectClientsFromChannelError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_chan_id = chan_id;
    let p_body_channel_connection_req_schema = channel_connection_req_schema;

    let uri_str = format!("{}/{domainID}/channels/{chanID}/disconnect", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), chanID=crate::apis::urlencode(p_path_chan_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_channel_connection_req_schema);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DisconnectClientsFromChannelError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

