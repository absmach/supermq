/*
 * SuperMQ Domains Service
 *
 * This is the Domains Server based on the OpenAPI 3.0 specification.  It is the HTTP API for managing platform domains. You can now help us improve the API whether it's by making changes to the definition itself or to the code. Some useful links: - [The SuperMQ repository](https://github.com/absmach/supermq) 
 *
 * The version of the OpenAPI document: 0.18.0
 * Contact: info@abstractmachines.fr
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`domains_domain_id_disable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainsDomainIdDisablePostError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`domains_domain_id_enable_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainsDomainIdEnablePostError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`domains_domain_id_freeze_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainsDomainIdFreezePostError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`domains_domain_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainsDomainIdGetError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`domains_domain_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainsDomainIdPatchError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status415(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`domains_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainsGetError {
    Status400(),
    Status401(),
    Status404(),
    Status422(),
    Status500(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`domains_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainsPostError {
    Status400(),
    Status401(),
    Status409(),
    Status415(),
    Status422(),
    Status500(),
    UnknownValue(serde_json::Value),
}


/// Disable a specific domain that is identified by the domain ID. 
pub async fn domains_domain_id_disable_post(configuration: &configuration::Configuration, domain_id: &str) -> Result<(), Error<DomainsDomainIdDisablePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;

    let uri_str = format!("{}/domains/{domainID}/disable", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainsDomainIdDisablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enables a specific domain that is identified by the domain ID. 
pub async fn domains_domain_id_enable_post(configuration: &configuration::Configuration, domain_id: &str) -> Result<(), Error<DomainsDomainIdEnablePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;

    let uri_str = format!("{}/domains/{domainID}/enable", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainsDomainIdEnablePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Freeze a specific domain that is identified by the domain ID. 
pub async fn domains_domain_id_freeze_post(configuration: &configuration::Configuration, domain_id: &str) -> Result<(), Error<DomainsDomainIdFreezePostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;

    let uri_str = format!("{}/domains/{domainID}/freeze", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainsDomainIdFreezePostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a specific domain that is identified by the domain ID. 
pub async fn domains_domain_id_get(configuration: &configuration::Configuration, domain_id: &str) -> Result<models::Domain, Error<DomainsDomainIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;

    let uri_str = format!("{}/domains/{domainID}", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Domain`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Domain`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainsDomainIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates name, metadata and tags of the domain. 
pub async fn domains_domain_id_patch(configuration: &configuration::Configuration, domain_id: &str, domain_update: models::DomainUpdate) -> Result<models::Domain, Error<DomainsDomainIdPatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_body_domain_update = domain_update;

    let uri_str = format!("{}/domains/{domainID}", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_domain_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Domain`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Domain`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainsDomainIdPatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves list of domains that the user have access. 
pub async fn domains_get(configuration: &configuration::Configuration, limit: Option<i32>, offset: Option<i32>, metadata: Option<std::collections::HashMap<String, serde_json::Value>>, status: Option<&str>, name: Option<&str>, permission: Option<&str>) -> Result<models::DomainsPage, Error<DomainsGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_metadata = metadata;
    let p_query_status = status;
    let p_query_name = name;
    let p_query_permission = permission;

    let uri_str = format!("{}/domains", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_metadata {
        req_builder = req_builder.query(&[("metadata", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_permission {
        req_builder = req_builder.query(&[("permission", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DomainsPage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DomainsPage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainsGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Adds new domain. 
pub async fn domains_post(configuration: &configuration::Configuration, domain_req_obj: models::DomainReqObj) -> Result<models::Domain, Error<DomainsPostError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_domain_req_obj = domain_req_obj;

    let uri_str = format!("{}/domains", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_domain_req_obj);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Domain`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Domain`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

