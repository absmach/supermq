/*
 * SuperMQ Journal Log Service
 *
 * This is the Journal Log Server based on the OpenAPI 3.0 specification.  It is the HTTP API for viewing journal log history. You can now help us improve the API whether it's by making changes to the definition itself or to the code. Some useful links: - [The SuperMQ repository](https://github.com/absmach/supermq) 
 *
 * The version of the OpenAPI document: 0.18.0
 * Contact: info@mainflux.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`domain_id_journal_client_client_id_telemetry_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainIdJournalClientClientIdTelemetryGetError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`domain_id_journal_entity_type_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainIdJournalEntityTypeIdGetError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`journal_user_user_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JournalUserUserIdGetError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}


/// Retrieves telemetry data for a specific client within a domain. This includes connection status, messages sent/received, and other metrics. 
pub async fn domain_id_journal_client_client_id_telemetry_get(configuration: &configuration::Configuration, domain_id: &str, client_id: &str) -> Result<models::Telemetry, Error<DomainIdJournalClientClientIdTelemetryGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_client_id = client_id;

    let uri_str = format!("{}/{domainID}/journal/client/{clientID}/telemetry", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), clientID=crate::apis::urlencode(p_path_client_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Telemetry`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Telemetry`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainIdJournalClientClientIdTelemetryGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a list of journal. Due to performance concerns, data is retrieved in subsets. The API must ensure that the entire dataset is consumed either by making subsequent requests, or by increasing the subset size of the initial request. 
pub async fn domain_id_journal_entity_type_id_get(configuration: &configuration::Configuration, domain_id: &str, entity_type: &str, id: &str, offset: Option<i32>, limit: Option<i32>, operation: Option<&str>, with_attributes: Option<bool>, with_metadata: Option<bool>, from: Option<&str>, to: Option<&str>, dir: Option<&str>) -> Result<models::JournalPage, Error<DomainIdJournalEntityTypeIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_entity_type = entity_type;
    let p_path_id = id;
    let p_query_offset = offset;
    let p_query_limit = limit;
    let p_query_operation = operation;
    let p_query_with_attributes = with_attributes;
    let p_query_with_metadata = with_metadata;
    let p_query_from = from;
    let p_query_to = to;
    let p_query_dir = dir;

    let uri_str = format!("{}/{domainID}/journal/{entityType}/{id}", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), entityType=crate::apis::urlencode(p_path_entity_type), id=crate::apis::urlencode(p_path_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_operation {
        req_builder = req_builder.query(&[("operation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_with_attributes {
        req_builder = req_builder.query(&[("with_attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_with_metadata {
        req_builder = req_builder.query(&[("with_metadata", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dir {
        req_builder = req_builder.query(&[("dir", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JournalPage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JournalPage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainIdJournalEntityTypeIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a list of journal. Due to performance concerns, data is retrieved in subsets. The API must ensure that the entire dataset is consumed either by making subsequent requests, or by increasing the subset size of the initial request. 
pub async fn journal_user_user_id_get(configuration: &configuration::Configuration, user_id: &str, offset: Option<i32>, limit: Option<i32>, operation: Option<&str>, with_attributes: Option<bool>, with_metadata: Option<bool>, from: Option<&str>, to: Option<&str>, dir: Option<&str>) -> Result<models::JournalPage, Error<JournalUserUserIdGetError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_user_id = user_id;
    let p_query_offset = offset;
    let p_query_limit = limit;
    let p_query_operation = operation;
    let p_query_with_attributes = with_attributes;
    let p_query_with_metadata = with_metadata;
    let p_query_from = from;
    let p_query_to = to;
    let p_query_dir = dir;

    let uri_str = format!("{}/journal/user/{userID}", configuration.base_path, userID=crate::apis::urlencode(p_path_user_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_operation {
        req_builder = req_builder.query(&[("operation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_with_attributes {
        req_builder = req_builder.query(&[("with_attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_with_metadata {
        req_builder = req_builder.query(&[("with_metadata", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from {
        req_builder = req_builder.query(&[("from", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_to {
        req_builder = req_builder.query(&[("to", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_dir {
        req_builder = req_builder.query(&[("dir", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::JournalPage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::JournalPage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<JournalUserUserIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

