/*
 * SuperMQ Groups Service
 *
 * This is the Groups Server based on the OpenAPI 3.0 specification.  It is the HTTP API for managing platform groups. You can now help us improve the API whether it's by making changes to the definition itself or to the code. Some useful links: - [The SuperMQ repository](https://github.com/absmach/supermq) 
 *
 * The version of the OpenAPI document: 0.18.0
 * Contact: info@abstractmachines.fr
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`add_children_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum AddChildrenGroupsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateGroupError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`disable_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DisableGroupError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`domain_id_groups_group_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DomainIdGroupsGroupIdDeleteError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`enable_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EnableGroupError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGroupError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_children_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChildrenGroupsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_group_hierarchy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGroupHierarchyError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListGroupsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_all_children_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveAllChildrenGroupsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_children_groups`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveChildrenGroupsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`remove_group_parent_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RemoveGroupParentGroupError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`set_group_parent_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SetGroupParentGroupError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_group_tags`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateGroupTagsError {
    Status400(),
    Status401(),
    Status403(),
    Status404(),
    Status409(),
    Status415(),
    Status422(),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}


/// Adds children groups for a specific group that is identified by the group ID. 
pub async fn add_children_groups(configuration: &configuration::Configuration, domain_id: &str, group_id: &str, children_group_req_obj: models::ChildrenGroupReqObj) -> Result<(), Error<AddChildrenGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;
    let p_body_children_group_req_obj = children_group_req_obj;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/children", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_children_group_req_obj);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<AddChildrenGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates new group that can be used for grouping entities. New account will be uniquely identified by its identity. 
pub async fn create_group(configuration: &configuration::Configuration, domain_id: &str, group_req_obj: models::GroupReqObj) -> Result<models::Group, Error<CreateGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_body_group_req_obj = group_req_obj;

    let uri_str = format!("{}/{domainID}/groups", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_req_obj);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Disables a specific group that is identifier by the group ID. 
pub async fn disable_group(configuration: &configuration::Configuration, domain_id: &str, group_id: &str) -> Result<models::Group, Error<DisableGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/disable", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DisableGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete group removes a group with the given id from repo and removes all the policies related to this group. 
pub async fn domain_id_groups_group_id_delete(configuration: &configuration::Configuration, domain_id: &str, group_id: &str) -> Result<(), Error<DomainIdGroupsGroupIdDeleteError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;

    let uri_str = format!("{}/{domainID}/groups/{groupID}", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DomainIdGroupsGroupIdDeleteError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Enables a specific group that is identifier by the group ID. 
pub async fn enable_group(configuration: &configuration::Configuration, domain_id: &str, group_id: &str) -> Result<models::Group, Error<EnableGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/enable", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EnableGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Gets info on a group specified by id. 
pub async fn get_group(configuration: &configuration::Configuration, domain_id: &str, group_id: &str) -> Result<models::Group, Error<GetGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;

    let uri_str = format!("{}/{domainID}/groups/{groupID}", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists groups up to a max level of hierarchy that can be fetched in one request ( max level = 5). Result can be filtered by metadata. Groups will be returned as JSON array or JSON tree. Due to performance concerns, result is returned in subsets. 
pub async fn list_children_groups(configuration: &configuration::Configuration, domain_id: &str, group_id: &str, limit: Option<i32>, offset: Option<i32>, start_level: Option<i32>, end_level: Option<i32>, tree: Option<bool>, metadata: Option<&str>, name: Option<&str>) -> Result<models::GroupsPage, Error<ListChildrenGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_start_level = start_level;
    let p_query_end_level = end_level;
    let p_query_tree = tree;
    let p_query_metadata = metadata;
    let p_query_name = name;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/children", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_level {
        req_builder = req_builder.query(&[("start_level", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_end_level {
        req_builder = req_builder.query(&[("end_level", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tree {
        req_builder = req_builder.query(&[("tree", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_metadata {
        req_builder = req_builder.query(&[("metadata", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsPage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsPage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListChildrenGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists groups heirarchy up to a max level of hierarchy that can be fetched in one request ( max level = 5). Result can be filtered by metadata. Groups will be returned as JSON array or JSON tree. Due to performance concerns, result is returned in subsets. 
pub async fn list_group_hierarchy(configuration: &configuration::Configuration, domain_id: &str, group_id: &str, level: Option<i32>, tree: Option<bool>, direction: Option<i32>) -> Result<models::GroupsHierarchyPage, Error<ListGroupHierarchyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;
    let p_query_level = level;
    let p_query_tree = tree;
    let p_query_direction = direction;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/hierarchy", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_level {
        req_builder = req_builder.query(&[("level", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tree {
        req_builder = req_builder.query(&[("tree", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_direction {
        req_builder = req_builder.query(&[("direction", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsHierarchyPage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsHierarchyPage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGroupHierarchyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Lists groups up to a max level of hierarchy that can be fetched in one request ( max level = 5). Result can be filtered by metadata. Groups will be returned as JSON array or JSON tree. Due to performance concerns, result is returned in subsets. 
pub async fn list_groups(configuration: &configuration::Configuration, domain_id: &str, limit: Option<i32>, offset: Option<i32>, level: Option<i32>, tree: Option<bool>, metadata: Option<&str>, name: Option<&str>, root_group: Option<bool>) -> Result<models::GroupsPage, Error<ListGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_level = level;
    let p_query_tree = tree;
    let p_query_metadata = metadata;
    let p_query_name = name;
    let p_query_root_group = root_group;

    let uri_str = format!("{}/{domainID}/groups", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_level {
        req_builder = req_builder.query(&[("level", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_tree {
        req_builder = req_builder.query(&[("tree", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_metadata {
        req_builder = req_builder.query(&[("metadata", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_root_group {
        req_builder = req_builder.query(&[("root_group", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupsPage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupsPage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes all children groups for a specific group that is identified by the group ID. 
pub async fn remove_all_children_groups(configuration: &configuration::Configuration, domain_id: &str, group_id: &str) -> Result<(), Error<RemoveAllChildrenGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/children/all", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveAllChildrenGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes children groups for a specific group that is identified by the group ID. 
pub async fn remove_children_groups(configuration: &configuration::Configuration, domain_id: &str, group_id: &str, children_group_req_obj: models::ChildrenGroupReqObj) -> Result<(), Error<RemoveChildrenGroupsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;
    let p_body_children_group_req_obj = children_group_req_obj;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/children", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_children_group_req_obj);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveChildrenGroupsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Removes a parent group from a specific group that is identified by the group ID. 
pub async fn remove_group_parent_group(configuration: &configuration::Configuration, domain_id: &str, group_id: &str, parent_group_req_obj: models::ParentGroupReqObj) -> Result<(), Error<RemoveGroupParentGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;
    let p_body_parent_group_req_obj = parent_group_req_obj;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/parent", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_parent_group_req_obj);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RemoveGroupParentGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Sets a parent group for a specific group that is identified by the group ID. 
pub async fn set_group_parent_group(configuration: &configuration::Configuration, domain_id: &str, group_id: &str, parent_group_req_obj: models::ParentGroupReqObj) -> Result<(), Error<SetGroupParentGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;
    let p_body_parent_group_req_obj = parent_group_req_obj;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/parent", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_parent_group_req_obj);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SetGroupParentGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Updates Name, Description or Metadata of a group. 
pub async fn update_group(configuration: &configuration::Configuration, domain_id: &str, group_id: &str, group_update: models::GroupUpdate) -> Result<models::Group, Error<UpdateGroupError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;
    let p_body_group_update = group_update;

    let uri_str = format!("{}/{domainID}/groups/{groupID}", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_update);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update is performed by replacing the current resource data with values provided in a request payload. Note that the group's ID will not be affected. 
pub async fn update_group_tags(configuration: &configuration::Configuration, domain_id: &str, group_id: &str, group_update_tags: models::GroupUpdateTags) -> Result<models::Group, Error<UpdateGroupTagsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_domain_id = domain_id;
    let p_path_group_id = group_id;
    let p_body_group_update_tags = group_update_tags;

    let uri_str = format!("{}/{domainID}/groups/{groupID}/tags", configuration.base_path, domainID=crate::apis::urlencode(p_path_domain_id), groupID=crate::apis::urlencode(p_path_group_id));
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_update_tags);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Group`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Group`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateGroupTagsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

